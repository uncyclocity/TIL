# 08. 함수

> References <br> <a href="http://www.yes24.com/Product/Goods/92742567?OzSrank=1">모던 자바스크립트 Deep Dive</a> _.이웅모_

## 1. 함수 기본 개념

- **함수** : **입력을 받아 출력을 내보내는 일련의 과정**에 대한 정의
- 입력을 전달 받는 변수를 **매개변수(Parameter)**, 입력을 **인수(argument)**, 그리고 출력을 **반환 값(return value)**이라고 한다.
- 인수를 전달하여 함수를 실행하는 것을 **호출**이라고 한다.
- 함수는 외부 상태에 의존하는 **부수 효과(side-effect)**의 유무에 따라 **순수/비순수 함수**로 나뉜다. <br>
  👉 인수에만 의존하는 **순수 함수**만을 조합하여 프로그램의 안정성을 높이는 것을 **함수형 프로그래밍**이라고 한다.
- 함수는 객체 타입의 **값**이므로 **리터럴**로 생성할 수 있다.

  ```javascript
  // 변수에 함수 리터럴을 할당
  const a = (x, y) => {
    return x + y;
  };
  ```

## 2. 함수 정의법

- **함수 선언문**

  ```javascript
  function add(x, y) {
    return x + y;
  }
  ```

  - **함수 이름**은 식별자가 된다. 그렇기에 함수 이름을 생략할 수 없다.
  - **표현식이 아닌 문**이기에 값이 될 수 없다.
  - **함수 호이스팅**에 의해 **맨 위에 함수가 정의 된 것**처럼 사용할 수 있다.

- **함수 표현식**

  ```javascript
  const foo = function add(x, y) {
    return x + y;
  };

  foo(1, 1);
  add(1, 1); // 에러
  ```

  - **표현식**이기에 값이 될 수 있다.
  - **함수 이름**을 명시할 경우 함수 선언문과 똑같다고 생각할 수 있으나, 이는 **중의적 표현**이기 때문이다. <br>
    👉 중의적 표현의 다른 예시로는 블록문일수도 객체 리터럴일수도 있는 `{}`가 있으며, JS 엔진이 함수 리터럴의 문맥에 따라 해석하여 판단한다.
  - 함수 이름을 생략할 수 있으며, 이를 **익명 함수**라고 한다.
  - 함수 이름은 **함수 내부**에만 작용하기에, **함수 외부에서 함수 이름으로 호출할 수 없다.**
  - **함수 호이스팅**이 발생하지 않으며, 변수에 할당한 함수 표현식은 **변수 호이스팅**이 발생한다.

- **생성자 함수 Function**

  ```javascript
  const add = new Function("x", "y", "return x + y");
  ```

  - **클로저**를 생성하지 않는다.
  - 권장되지 않는 방식이다.

- **화살표 함수**

  ```javascript
  const add = (x, y) => {
    return x + y;
  };
  ```

  - ES6에서 새롭게 도입되었으며, 기본적으로 **익명 함수**이다.
  - 표현은 물론, 내부 동작까지 일반 함수에 비해 간략화되어 있다.
  - 일반 함수와의 큰 차이점
    - **this에 바인딩할 객체**가 **정적으로 자신의 상위 스코프로 결정**되며, call/apply/bind 메소드를 통해 **this를 변경할 수도 없다.**
    - **prototype 프로퍼티**를 갖지 않기 때문에 생성자 함수로 사용할 수 없다.
    - **arguments 변수**가 전달되지 않는다.

## 3. 매개변수와 인수

- 매개변수는 함수가 호출되면 **함수 내부에서 선언**되어, 초기화를 통해 undefined가 할당된 다음 인수가 할당된다. <br>
  👉 인수가 부족할 경우, 인수를 전달받지 못한 매개변수는 undefined 상태 그대로 할당되어 있다.
- 이상적인 함수는 **한가지 일만 하는 함수**이며, 매개변수 또한 **적으면 적을수록 좋다.** <br>
  👉 매개변수가 많으면 많을수록 **인수 전달의 순서**를 고려해야 하기에, 유지보수성이 나빠진다. <br>
  => **객체로 압축해서 전달**하면 순서를 고려하지 않아도 된다!
- 매개변수 또한 변수이기에 **call by value**와 **call by reference** 법칙을 따른다. <br>
  👉 원시값은 부수효과가 발생할 걱정이 없으나, 객체의 경우 발생할 수 있다. <br>
  => 외부 객체의 변화를 일으키는 함수는 **비순수 함수**가 된다.

## 4. 반환문

- **return 키워드**를 통해 JS의 모든 값을 반환할 수 있다. <br>
  👉 함수 호출문이 **표현식**인 이유이다.
- 반환문을 생략할 경우 **undefined를 반환**한다.

## 5. 즉시 실행 함수

```javascript
(function () {
  const x = 1,
    y = 1;
  return x + y;
})();
```

- **정의와 동시에 실행되는 함수**이다.
- **익명함수**를 사용하는 것이 일반적이다.
- **그룹 연산자**(`()`)로 감싸서 사용한다. 만약 감싸지 않을 경우 **함수 선언문**으로 인식하여 에러가 발생한다.
- 한번만 호출되고 그 이후 **재호출이 불가능**하다.
- **전역변수의 선언을 방지**하는 데 주로 사용된다.

## 6. 중첩 함수

```javascript
function outer() {
  var x = 1;
  // 중첩 함수
  function inner() {
    var y = 2;
    // 외부 함수의 변수를 참조할 수 있다.
    console.log(x + y); // 3
  }
  inner();
}
outer();
```

- **중첩 함수**는 **함수 내부에 정의된 함수**를 말한다.
- 중첩 함수는 **내부 함수**라고도 하며, 이 경우 중첩 함수를 포함하는 함수를 **외부 함수**라고 한다.
- 코드블록에서 호이스팅으로 인한 혼란을 야기할 수도 있기에 권장되지 않는다.

## 7. 콜백 함수와 고차 함수

- **콜백 함수**란 **다른 함수로 전달되는 함수**를 말한다.
- 콜백 함수를 전달받은 함수는 **고차 함수**라고 한다.
- 중첩 함수가 외부 함수의 **헬퍼 함수 역할**을 하듯이, 콜백 함수 또한 고차 함수의 헬퍼 함수 역할을 한다. <br>
  👉 고정되어 있는 중첩 함수와 달리, 콜백 함수는 어떤 함수든 될 수 있기에 유연성이 좋다.
- 콜백 함수가 고차 함수 내에서만 호출 될 경우, **익명 함수 리터럴**로 정의하여 **바로 고차 함수에 전달**하는 것이 일반적이다.

  ```javascript
  repeat(5, (i) => i % 2 && console.log(i));
  ```
